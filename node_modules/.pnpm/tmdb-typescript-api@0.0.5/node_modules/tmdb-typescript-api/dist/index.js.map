{"version":3,"file":"index.js","sources":["../node_modules/rxjs/src/util/isFunction.ts","../node_modules/rxjs/src/util/isObject.ts","../node_modules/rxjs/src/util/tryCatch.ts","../node_modules/rxjs/src/Subscription.ts","../node_modules/rxjs/src/util/toSubscriber.ts","../node_modules/rxjs/src/operator/map.ts","../node_modules/rxjs/src/observable/dom/AjaxObservable.ts","../node_modules/rxjs/src/util/isPromise.ts","../node_modules/rxjs/src/observable/PromiseObservable.ts","../node_modules/rxjs/src/observable/IteratorObservable.ts","../node_modules/rxjs/src/util/isScheduler.ts","../node_modules/rxjs/src/operator/observeOn.ts","../node_modules/tslib/tslib.es6.js","../node_modules/rxjs/src/util/root.ts","../node_modules/rxjs/src/util/isArray.ts","../node_modules/rxjs/src/util/errorObject.ts","../node_modules/rxjs/src/util/UnsubscriptionError.ts","../node_modules/rxjs/src/Observer.ts","../node_modules/rxjs/src/symbol/rxSubscriber.ts","../node_modules/rxjs/src/Subscriber.ts","../node_modules/rxjs/src/symbol/observable.ts","../node_modules/rxjs/src/Observable.ts","../node_modules/rxjs/src/observable/dom/ajax.ts","../node_modules/rxjs/src/add/observable/dom/ajax.ts","../node_modules/rxjs/src/add/operator/map.ts","../node_modules/rxjs/src/util/isArrayLike.ts","../node_modules/rxjs/src/symbol/iterator.ts","../node_modules/rxjs/src/observable/ScalarObservable.ts","../node_modules/rxjs/src/observable/EmptyObservable.ts","../node_modules/rxjs/src/observable/ArrayObservable.ts","../node_modules/rxjs/src/observable/ArrayLikeObservable.ts","../node_modules/rxjs/src/Notification.ts","../node_modules/rxjs/src/observable/FromObservable.ts","../node_modules/rxjs/src/observable/from.ts","../node_modules/rxjs/src/add/observable/from.ts","../src/helper.ts","../src/features/search-api.ts","../src/context.ts","../src/features/movies-api.ts","../src/features/collections-api.ts","../src/features/people-api.ts","../src/features/tv-api.ts","../src/tmdb-api.ts","../src/model/collection-details.ts","../src/model/movie-details.ts","../src/model/person-details.ts","../src/model/tv-show-details.ts"],"sourcesContent":["export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n};\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface AnonymousSubscription {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = AnonymousSubscription | Function | void;\n\nexport interface ISubscription extends AnonymousSubscription {\n  unsubscribe(): void;\n  readonly closed: boolean;\n}\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements ISubscription {\n  public static EMPTY: Subscription = (function(empty: any){\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  protected _parent: Subscription = null;\n  protected _parents: Subscription[] = null;\n  private _subscriptions: ISubscription[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { PartialObserver, empty as emptyObserver } from '../Observer';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(this: Observable<T>, project: (value: T, index: number) => R, thisArg?: any): Observable<R> {\n  if (typeof project !== 'function') {\n    throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n  }\n  return this.lift(new MapOperator(project, thisArg));\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { root } from '../../util/root';\nimport { tryCatch } from '../../util/tryCatch';\nimport { errorObject } from '../../util/errorObject';\nimport { Observable } from '../../Observable';\nimport { Subscriber } from '../../Subscriber';\nimport { TeardownLogic } from '../../Subscription';\nimport { MapOperator } from '../../operator/map';\n\nexport interface AjaxRequest {\n  url?: string;\n  body?: any;\n  user?: string;\n  async?: boolean;\n  method?: string;\n  headers?: Object;\n  timeout?: number;\n  password?: string;\n  hasContent?: boolean;\n  crossDomain?: boolean;\n  withCredentials?: boolean;\n  createXHR?: () => XMLHttpRequest;\n  progressSubscriber?: Subscriber<any>;\n  responseType?: string;\n}\n\nfunction getCORSRequest(this: AjaxRequest): XMLHttpRequest {\n  if (root.XMLHttpRequest) {\n    return new root.XMLHttpRequest();\n  } else if (!!root.XDomainRequest) {\n    return new root.XDomainRequest();\n  } else {\n    throw new Error('CORS is not supported by your browser');\n  }\n}\n\nfunction getXMLHttpRequest(): XMLHttpRequest {\n  if (root.XMLHttpRequest) {\n    return new root.XMLHttpRequest();\n  } else {\n    let progId: string;\n    try {\n      const progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n      for (let i = 0; i < 3; i++) {\n        try {\n          progId = progIds[i];\n          if (new root.ActiveXObject(progId)) {\n            break;\n          }\n        } catch (e) {\n          //suppress exceptions\n        }\n      }\n      return new root.ActiveXObject(progId);\n    } catch (e) {\n      throw new Error('XMLHttpRequest is not supported by your browser');\n    }\n  }\n}\n\nexport interface AjaxCreationMethod {\n  (urlOrRequest: string | AjaxRequest): Observable<AjaxResponse>;\n  get(url: string, headers?: Object): Observable<AjaxResponse>;\n  post(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\n  put(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\n  patch(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;\n  delete(url: string, headers?: Object): Observable<AjaxResponse>;\n  getJSON<T>(url: string, headers?: Object): Observable<T>;\n}\n\nexport function ajaxGet(url: string, headers: Object = null) {\n  return new AjaxObservable<AjaxResponse>({ method: 'GET', url, headers });\n};\n\nexport function ajaxPost(url: string, body?: any, headers?: Object): Observable<AjaxResponse> {\n  return new AjaxObservable<AjaxResponse>({ method: 'POST', url, body, headers });\n};\n\nexport function ajaxDelete(url: string, headers?: Object): Observable<AjaxResponse> {\n  return new AjaxObservable<AjaxResponse>({ method: 'DELETE', url, headers });\n};\n\nexport function ajaxPut(url: string, body?: any, headers?: Object): Observable<AjaxResponse> {\n  return new AjaxObservable<AjaxResponse>({ method: 'PUT', url, body, headers });\n};\n\nexport function ajaxPatch(url: string, body?: any, headers?: Object): Observable<AjaxResponse> {\n  return new AjaxObservable<AjaxResponse>({ method: 'PATCH', url, body, headers });\n};\n\nexport function ajaxGetJSON<T>(url: string, headers?: Object): Observable<T> {\n  return new AjaxObservable<AjaxResponse>({ method: 'GET', url, responseType: 'json', headers })\n    .lift<T>(new MapOperator<AjaxResponse, T>((x: AjaxResponse, index: number): T => x.response, null));\n};\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class AjaxObservable<T> extends Observable<T> {\n  /**\n   * Creates an observable for an Ajax request with either a request object with\n   * url, headers, etc or a string for a URL.\n   *\n   * @example\n   * source = Rx.Observable.ajax('/products');\n   * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });\n   *\n   * @param {string|Object} request Can be one of the following:\n   *   A string of the URL to make the Ajax call.\n   *   An object with the following properties\n   *   - url: URL of the request\n   *   - body: The body of the request\n   *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n   *   - async: Whether the request is async\n   *   - headers: Optional headers\n   *   - crossDomain: true if a cross domain request, else false\n   *   - createXHR: a function to override if you need to use an alternate\n   *   XMLHttpRequest implementation.\n   *   - resultSelector: a function to use to alter the output value type of\n   *   the Observable. Gets {@link AjaxResponse} as an argument.\n   * @return {Observable} An observable sequence containing the XMLHttpRequest.\n   * @static true\n   * @name ajax\n   * @owner Observable\n  */\n  static create: AjaxCreationMethod = (() => {\n    const create: any = (urlOrRequest: string | AjaxRequest) => {\n      return new AjaxObservable(urlOrRequest);\n    };\n\n    create.get = ajaxGet;\n    create.post = ajaxPost;\n    create.delete = ajaxDelete;\n    create.put = ajaxPut;\n    create.patch = ajaxPatch;\n    create.getJSON = ajaxGetJSON;\n\n    return <AjaxCreationMethod>create;\n  })();\n\n  private request: AjaxRequest;\n\n  constructor(urlOrRequest: string | AjaxRequest) {\n    super();\n\n    const request: AjaxRequest = {\n      async: true,\n      createXHR: function(this: AjaxRequest) {\n        return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();\n      },\n      crossDomain: false,\n      withCredentials: false,\n      headers: {},\n      method: 'GET',\n      responseType: 'json',\n      timeout: 0\n    };\n\n    if (typeof urlOrRequest === 'string') {\n      request.url = urlOrRequest;\n    } else {\n      for (const prop in urlOrRequest) {\n        if (urlOrRequest.hasOwnProperty(prop)) {\n          request[prop] = urlOrRequest[prop];\n        }\n      }\n    }\n\n    this.request = request;\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    return new AjaxSubscriber(subscriber, this.request);\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AjaxSubscriber<T> extends Subscriber<Event> {\n  private xhr: XMLHttpRequest;\n  private done: boolean = false;\n\n  constructor(destination: Subscriber<T>, public request: AjaxRequest) {\n    super(destination);\n\n    const headers = request.headers = request.headers || {};\n\n    // force CORS if requested\n    if (!request.crossDomain && !headers['X-Requested-With']) {\n      headers['X-Requested-With'] = 'XMLHttpRequest';\n    }\n\n    // ensure content type is set\n    if (!('Content-Type' in headers) && !(root.FormData && request.body instanceof root.FormData) && typeof request.body !== 'undefined') {\n      headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n    }\n\n    // properly serialize body\n    request.body = this.serializeBody(request.body, request.headers['Content-Type']);\n\n    this.send();\n  }\n\n  next(e: Event): void {\n    this.done = true;\n    const { xhr, request, destination } = this;\n    const response = new AjaxResponse(e, xhr, request);\n\n    destination.next(response);\n  }\n\n  private send(): XMLHttpRequest {\n    const {\n      request,\n      request: { user, method, url, async, password, headers, body }\n    } = this;\n    const createXHR = request.createXHR;\n    const xhr: XMLHttpRequest = tryCatch(createXHR).call(request);\n\n    if (<any>xhr === errorObject) {\n      this.error(errorObject.e);\n    } else {\n      this.xhr = xhr;\n\n      // set up the events before open XHR\n      // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n      // You need to add the event listeners before calling open() on the request.\n      // Otherwise the progress events will not fire.\n      this.setupEvents(xhr, request);\n      // open XHR\n      let result: any;\n      if (user) {\n        result = tryCatch(xhr.open).call(xhr, method, url, async, user, password);\n      } else {\n        result = tryCatch(xhr.open).call(xhr, method, url, async);\n      }\n\n      if (result === errorObject) {\n        this.error(errorObject.e);\n        return null;\n      }\n\n      // timeout, responseType and withCredentials can be set once the XHR is open\n      if (async) {\n        xhr.timeout = request.timeout;\n        xhr.responseType = request.responseType;\n      }\n\n      if ('withCredentials' in xhr) {\n        xhr.withCredentials = !!request.withCredentials;\n      }\n\n      // set headers\n      this.setHeaders(xhr, headers);\n\n      // finally send the request\n      result = body ? tryCatch(xhr.send).call(xhr, body) : tryCatch(xhr.send).call(xhr);\n      if (result === errorObject) {\n        this.error(errorObject.e);\n        return null;\n      }\n    }\n\n    return xhr;\n  }\n\n  private serializeBody(body: any, contentType?: string) {\n    if (!body || typeof body === 'string') {\n      return body;\n    } else if (root.FormData && body instanceof root.FormData) {\n      return body;\n    }\n\n    if (contentType) {\n      const splitIndex = contentType.indexOf(';');\n      if (splitIndex !== -1) {\n        contentType = contentType.substring(0, splitIndex);\n      }\n    }\n\n    switch (contentType) {\n      case 'application/x-www-form-urlencoded':\n        return Object.keys(body).map(key => `${encodeURI(key)}=${encodeURI(body[key])}`).join('&');\n      case 'application/json':\n        return JSON.stringify(body);\n      default:\n        return body;\n    }\n  }\n\n  private setHeaders(xhr: XMLHttpRequest, headers: Object) {\n    for (let key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  }\n\n  private setupEvents(xhr: XMLHttpRequest, request: AjaxRequest) {\n    const progressSubscriber = request.progressSubscriber;\n\n    function xhrTimeout(this: XMLHttpRequest, e: ProgressEvent) {\n      const {subscriber, progressSubscriber, request } = (<any>xhrTimeout);\n      if (progressSubscriber) {\n        progressSubscriber.error(e);\n      }\n      subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.\n    };\n    xhr.ontimeout = xhrTimeout;\n    (<any>xhrTimeout).request = request;\n    (<any>xhrTimeout).subscriber = this;\n    (<any>xhrTimeout).progressSubscriber = progressSubscriber;\n    if (xhr.upload && 'withCredentials' in xhr) {\n      if (progressSubscriber) {\n        let xhrProgress: (e: ProgressEvent) => void;\n        xhrProgress = function(e: ProgressEvent) {\n          const { progressSubscriber } = (<any>xhrProgress);\n          progressSubscriber.next(e);\n        };\n        if (root.XDomainRequest) {\n          xhr.onprogress = xhrProgress;\n        } else {\n          xhr.upload.onprogress = xhrProgress;\n        }\n        (<any>xhrProgress).progressSubscriber = progressSubscriber;\n      }\n      let xhrError: (e: ErrorEvent) => void;\n      xhrError = function(this: XMLHttpRequest, e: ErrorEvent) {\n        const { progressSubscriber, subscriber, request } = (<any>xhrError);\n        if (progressSubscriber) {\n          progressSubscriber.error(e);\n        }\n        subscriber.error(new AjaxError('ajax error', this, request));\n      };\n      xhr.onerror = xhrError;\n      (<any>xhrError).request = request;\n      (<any>xhrError).subscriber = this;\n      (<any>xhrError).progressSubscriber = progressSubscriber;\n    }\n\n    function xhrReadyStateChange(this: XMLHttpRequest, e: ProgressEvent) {\n      const { subscriber, progressSubscriber, request } = (<any>xhrReadyStateChange);\n      if (this.readyState === 4) {\n        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n        let status: number = this.status === 1223 ? 204 : this.status;\n        let response: any = (this.responseType === 'text' ?  (\n          this.response || this.responseText) : this.response);\n\n        // fix status code when it is 0 (0 status is undocumented).\n        // Occurs when accessing file resources or on Android 4.1 stock browser\n        // while retrieving files from application cache.\n        if (status === 0) {\n          status = response ? 200 : 0;\n        }\n\n        if (200 <= status && status < 300) {\n          if (progressSubscriber) {\n            progressSubscriber.complete();\n          }\n          subscriber.next(e);\n          subscriber.complete();\n        } else {\n          if (progressSubscriber) {\n            progressSubscriber.error(e);\n          }\n          subscriber.error(new AjaxError('ajax error ' + status, this, request));\n        }\n      }\n    };\n    xhr.onreadystatechange = xhrReadyStateChange;\n    (<any>xhrReadyStateChange).subscriber = this;\n    (<any>xhrReadyStateChange).progressSubscriber = progressSubscriber;\n    (<any>xhrReadyStateChange).request = request;\n  }\n\n  unsubscribe() {\n    const { done, xhr } = this;\n    if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n      xhr.abort();\n    }\n    super.unsubscribe();\n  }\n}\n\n/**\n * A normalized AJAX response.\n *\n * @see {@link ajax}\n *\n * @class AjaxResponse\n */\nexport class AjaxResponse {\n  /** @type {number} The HTTP status code */\n  status: number;\n\n  /** @type {string|ArrayBuffer|Document|object|any} The response data */\n  response: any;\n\n  /** @type {string} The raw responseText */\n  responseText: string;\n\n  /** @type {string} The responseType (e.g. 'json', 'arraybuffer', or 'xml') */\n  responseType: string;\n\n  constructor(public originalEvent: Event, public xhr: XMLHttpRequest, public request: AjaxRequest) {\n    this.status = xhr.status;\n    this.responseType = xhr.responseType || request.responseType;\n\n    switch (this.responseType) {\n      case 'json':\n        if ('response' in xhr) {\n          //IE does not support json as responseType, parse it internally\n          this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n        } else {\n          this.response = JSON.parse(xhr.responseText || 'null');\n        }\n        break;\n      case 'xml':\n        this.response = xhr.responseXML;\n        break;\n      case 'text':\n      default:\n        this.response = ('response' in xhr) ? xhr.response : xhr.responseText;\n        break;\n    }\n  }\n}\n\n/**\n * A normalized AJAX error.\n *\n * @see {@link ajax}\n *\n * @class AjaxError\n */\nexport class AjaxError extends Error {\n  /** @type {XMLHttpRequest} The XHR instance associated with the error */\n  xhr: XMLHttpRequest;\n\n  /** @type {AjaxRequest} The AjaxRequest associated with the error */\n  request: AjaxRequest;\n\n  /** @type {number} The HTTP status code */\n  status: number;\n\n  constructor(message: string, xhr: XMLHttpRequest, request: AjaxRequest) {\n    super(message);\n    this.message = message;\n    this.xhr = xhr;\n    this.request = request;\n    this.status = xhr.status;\n  }\n}\n\n/**\n * @see {@link ajax}\n *\n * @class AjaxTimeoutError\n */\nexport class AjaxTimeoutError extends AjaxError {\n  constructor(xhr: XMLHttpRequest, request: AjaxRequest) {\n    super('ajax timeout', xhr, request);\n  }\n}\n","export function isPromise<T>(value: any | Promise<T>): value is Promise<T> {\n  return value && typeof (<any>value).subscribe !== 'function' && typeof (value as any).then === 'function';\n}\n","import { root } from '../util/root';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class PromiseObservable<T> extends Observable<T> {\n\n  public value: T;\n\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n  static create<T>(promise: PromiseLike<T>, scheduler?: IScheduler): Observable<T> {\n    return new PromiseObservable(promise, scheduler);\n  }\n\n  constructor(private promise: PromiseLike<T>, private scheduler?: IScheduler) {\n    super();\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const promise = this.promise;\n    const scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.next(value);\n              subscriber.complete();\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.error(err);\n            }\n          }\n        )\n        .then(null, err => {\n          // escape the promise trap, throw unhandled errors\n          root.setTimeout(() => { throw err; });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber });\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchNext, 0, { value, subscriber }));\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchError, 0, { err, subscriber }));\n            }\n          })\n          .then(null, (err) => {\n            // escape the promise trap, throw unhandled errors\n            root.setTimeout(() => { throw err; });\n          });\n      }\n    }\n  }\n}\n\ninterface DispatchNextArg<T> {\n  subscriber: Subscriber<T>;\n  value: T;\n}\nfunction dispatchNext<T>(arg: DispatchNextArg<T>) {\n  const { value, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\ninterface DispatchErrorArg<T> {\n  subscriber: Subscriber<T>;\n  err: any;\n}\nfunction dispatchError<T>(arg: DispatchErrorArg<T>) {\n  const { err, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}\n","import { root } from '../util/root';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { TeardownLogic } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class IteratorObservable<T> extends Observable<T> {\n  private iterator: any;\n\n  static create<T>(iterator: any, scheduler?: IScheduler): IteratorObservable<T> {\n    return new IteratorObservable(iterator, scheduler);\n  }\n\n  static dispatch(state: any) {\n\n    const { index, hasError, iterator, subscriber } = state;\n\n    if (hasError) {\n      subscriber.error(state.error);\n      return;\n    }\n\n    let result = iterator.next();\n    if (result.done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(result.value);\n    state.index = index + 1;\n\n    if (subscriber.closed) {\n      if (typeof iterator.return === 'function') {\n        iterator.return();\n      }\n      return;\n    }\n\n    (<any> this).schedule(state);\n  }\n\n  constructor(iterator: any, private scheduler?: IScheduler) {\n    super();\n\n    if (iterator == null) {\n      throw new Error('iterator cannot be null.');\n    }\n\n    this.iterator = getIterator(iterator);\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n\n    let index = 0;\n    const { iterator, scheduler } = this;\n\n    if (scheduler) {\n      return scheduler.schedule(IteratorObservable.dispatch, 0, {\n        index, iterator, subscriber\n      });\n    } else {\n      do {\n        let result = iterator.next();\n        if (result.done) {\n          subscriber.complete();\n          break;\n        } else {\n          subscriber.next(result.value);\n        }\n        if (subscriber.closed) {\n          if (typeof iterator.return === 'function') {\n            iterator.return();\n          }\n          break;\n        }\n      } while (true);\n    }\n  }\n}\n\nclass StringIterator {\n  constructor(private str: string,\n              private idx: number = 0,\n              private len: number = str.length) {\n  }\n  [Symbol_iterator]() { return (this); }\n  next() {\n    return this.idx < this.len ? {\n        done: false,\n        value: this.str.charAt(this.idx++)\n    } : {\n        done: true,\n        value: undefined\n    };\n  }\n}\n\nclass ArrayIterator {\n  constructor(private arr: Array<any>,\n              private idx: number = 0,\n              private len: number = toLength(arr)) {\n  }\n  [Symbol_iterator]() { return this; }\n  next() {\n    return this.idx < this.len ? {\n        done: false,\n        value: this.arr[this.idx++]\n    } : {\n        done: true,\n        value: undefined\n    };\n  }\n}\n\nfunction getIterator(obj: any) {\n  const i = obj[Symbol_iterator];\n  if (!i && typeof obj === 'string') {\n    return new StringIterator(obj);\n  }\n  if (!i && obj.length !== undefined) {\n    return new ArrayIterator(obj);\n  }\n  if (!i) {\n    throw new TypeError('object is not iterable');\n  }\n  return obj[Symbol_iterator]();\n}\n\nconst maxSafeInteger = Math.pow(2, 53) - 1;\n\nfunction toLength(o: any) {\n  let len = +o.length;\n  if (isNaN(len)) {\n      return 0;\n  }\n  if (len === 0 || !numberIsFinite(len)) {\n      return len;\n  }\n  len = sign(len) * Math.floor(Math.abs(len));\n  if (len <= 0) {\n      return 0;\n  }\n  if (len > maxSafeInteger) {\n      return maxSafeInteger;\n  }\n  return len;\n}\n\nfunction numberIsFinite(value: any) {\n  return typeof value === 'number' && root.isFinite(value);\n}\n\nfunction sign(value: any) {\n  let valueAsNumber = +value;\n  if (valueAsNumber === 0) {\n    return valueAsNumber;\n  }\n  if (isNaN(valueAsNumber)) {\n    return valueAsNumber;\n  }\n  return valueAsNumber < 0 ? -1 : 1;\n}\n","import { Scheduler } from '../Scheduler';\nexport function isScheduler(value: any): value is Scheduler {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","import { Observable } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { Operator } from '../Operator';\nimport { PartialObserver } from '../Observer';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { TeardownLogic } from '../Subscription';\nimport { Action } from '../scheduler/Action';\n\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nexport function observeOn<T>(this: Observable<T>, scheduler: IScheduler, delay: number = 0): Observable<T> {\n  return this.lift(new ObserveOnOperator(scheduler, delay));\n}\n\nexport class ObserveOnOperator<T> implements Operator<T, T> {\n  constructor(private scheduler: IScheduler, private delay: number = 0) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ObserveOnSubscriber<T> extends Subscriber<T> {\n  static dispatch(this: Action<ObserveOnMessage>, arg: ObserveOnMessage) {\n    const { notification, destination } = arg;\n    notification.observe(destination);\n    this.unsubscribe();\n  }\n\n  constructor(destination: Subscriber<T>,\n              private scheduler: IScheduler,\n              private delay: number = 0) {\n    super(destination);\n  }\n\n  private scheduleMessage(notification: Notification<any>): void {\n    this.add(this.scheduler.schedule(\n      ObserveOnSubscriber.dispatch,\n      this.delay,\n      new ObserveOnMessage(notification, this.destination)\n    ));\n  }\n\n  protected _next(value: T): void {\n    this.scheduleMessage(Notification.createNext(value));\n  }\n\n  protected _error(err: any): void {\n    this.scheduleMessage(Notification.createError(err));\n  }\n\n  protected _complete(): void {\n    this.scheduleMessage(Notification.createComplete());\n  }\n}\n\nexport class ObserveOnMessage {\n  constructor(public notification: Notification<any>,\n              public destination: PartialObserver<any>) {\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}","declare let global: any;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\n\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\nconst _root: any = __window || __global || __self;\n\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n  if (!_root) {\n    throw new Error('RxJS could not find any global context (window, self, global)');\n  }\n})();\n\nexport { _root as root };","export const isArray = Array.isArray || (<T>(x: any): x is T[] => x && typeof x.length === 'number');\n","// typeof any so that it we don't have to cast when comparing a result to the error object\nexport const errorObject: any = { e: {} };","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  constructor(public errors: any[]) {\n    super();\n    const err: any = Error.call(this, errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (<any> this).name = err.name = 'UnsubscriptionError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","export interface NextObserver<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface ErrorObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface CompletionObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void { throw err; },\n  complete(): void { /*noop*/ }\n};\n","import { root } from '../util/root';\n\nconst Symbol: any = root.Symbol;\n\nexport const rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n  Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { Observer, PartialObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { rxSubscriber as rxSubscriberSymbol } from './symbol/rxSubscriber';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  public syncErrorValue: any = null;\n  public syncErrorThrown: boolean = false;\n  public syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.destination = (<Subscriber<any>> destinationOrNext);\n            (<any> this.destination).add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  protected _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parentSubscriber.syncErrorValue = err;\n        _parentSubscriber.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n    return false;\n  }\n\n  protected _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { root } from '../util/root';\n\nexport function getSymbolObservable(context: any) {\n  let $$observable: any;\n  let Symbol = context.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      $$observable = Symbol.observable;\n    } else {\n        $$observable = Symbol('observable');\n        Symbol.observable = $$observable;\n    }\n  } else {\n    $$observable = '@@observable';\n  }\n\n  return $$observable;\n}\n\nexport const observable = getSymbolObservable(root);\n\n/**\n * @deprecated use observable instead\n */\nexport const $$observable = observable;\n","import { PartialObserver } from './Observer';\nimport { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, AnonymousSubscription, TeardownLogic } from './Subscription';\nimport { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { IfObservable } from './observable/IfObservable';\nimport { ErrorObservable } from './observable/ErrorObservable';\nimport { observable as Symbol_observable } from './symbol/observable';\n\nexport interface Subscribable<T> {\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): AnonymousSubscription;\n}\n\nexport type SubscribableOrPromise<T> = Subscribable<T> | PromiseLike<T>;\nexport type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  public _isScalar: boolean = false;\n\n  protected source: Observable<any>;\n  protected operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(): Subscription;\n  subscribe(observer: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n   * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n   * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n   * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n   *\n   * @example <caption>Subscribe with an Observer</caption>\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Subscribe with functions</caption>\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Cancel a subscription</caption>\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   *\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (sink.syncErrorThrowable) {\n      sink.syncErrorThrowable = false;\n      if (sink.syncErrorThrown) {\n        throw sink.syncErrorValue;\n      }\n    }\n\n    return sink;\n  }\n\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      sink.syncErrorThrown = true;\n      sink.syncErrorValue = err;\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void> {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        if (subscription) {\n          // if there is a subscription, then we can surmise\n          // the next handling is asynchronous. Any errors thrown\n          // need to be rejected explicitly and unsubscribe must be\n          // called manually\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        } else {\n          // if there is NO subscription, then we're getting a nexted\n          // value synchronously during subscription. We can just call it.\n          // If it errors, Observable's `subscribe` will ensure the\n          // unsubscription logic is called, then synchronously rethrow the error.\n          // After that, Promise will trap the error and send it\n          // down the rejection path.\n          next(value);\n        }\n      }, reject, resolve);\n    });\n  }\n\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words\n  static if: typeof IfObservable.create;\n  static throw: typeof ErrorObservable.create;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n}\n","import {  AjaxObservable, AjaxCreationMethod  } from './AjaxObservable';\n\nexport const ajax: AjaxCreationMethod = AjaxObservable.create;","import { Observable } from '../../../Observable';\nimport { ajax as staticAjax } from '../../../observable/dom/ajax';\nimport { AjaxCreationMethod } from '../../../observable/dom/AjaxObservable';\n\nObservable.ajax = staticAjax;\n\ndeclare module '../../../Observable' {\n  namespace Observable {\n    export let ajax: AjaxCreationMethod;\n  }\n}","\nimport { Observable } from '../../Observable';\nimport { map } from '../../operator/map';\n\nObservable.prototype.map = map;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    map: typeof map;\n  }\n}","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number');","import { root } from '../util/root';\n\nexport function symbolIteratorPonyfill(root: any) {\n  const Symbol: any = root.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (!Symbol.iterator) {\n      Symbol.iterator = Symbol('iterator polyfill');\n    }\n    return Symbol.iterator;\n  } else {\n    // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n    const { Set } = root;\n    if (Set && typeof new Set()['@@iterator'] === 'function') {\n      return '@@iterator';\n    }\n    const { Map } = root;\n    // required for compatability with es6-shim\n    if (Map) {\n      let keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        let key = keys[i];\n        // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n        if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {\n          return key;\n        }\n      }\n    }\n    return '@@iterator';\n  }\n}\n\nexport const iterator = symbolIteratorPonyfill(root);\n\n/**\n * @deprecated use iterator instead\n */\nexport const $$iterator = iterator;\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ScalarObservable<T> extends Observable<T> {\n  static create<T>(value: T, scheduler?: IScheduler): ScalarObservable<T> {\n    return new ScalarObservable(value, scheduler);\n  }\n\n  static dispatch(state: any): void {\n    const { done, value, subscriber } = state;\n\n    if (done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(value);\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.done = true;\n    (<any> this).schedule(state);\n  }\n\n  _isScalar: boolean = true;\n\n  constructor(public value: T, private scheduler?: IScheduler) {\n    super();\n    if (scheduler) {\n      this._isScalar = false;\n    }\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const value = this.value;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ScalarObservable.dispatch, 0, {\n        done: false, value, subscriber\n      });\n    } else {\n      subscriber.next(value);\n      if (!subscriber.closed) {\n        subscriber.complete();\n      }\n    }\n  }\n}\n","import { IScheduler } from '../Scheduler';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\n\nexport interface DispatchArg<T> {\n  subscriber: Subscriber<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class EmptyObservable<T> extends Observable<T> {\n\n  /**\n   * Creates an Observable that emits no items to the Observer and immediately\n   * emits a complete notification.\n   *\n   * <span class=\"informal\">Just emits 'complete', and nothing else.\n   * </span>\n   *\n   * <img src=\"./img/empty.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the complete notification. It can be used for composing with other\n   * Observables, such as in a {@link mergeMap}.\n   *\n   * @example <caption>Emit the number 7, then complete.</caption>\n   * var result = Rx.Observable.empty().startWith(7);\n   * result.subscribe(x => console.log(x));\n   *\n   * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n   * var interval = Rx.Observable.interval(1000);\n   * var result = interval.mergeMap(x =>\n   *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n   * );\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following to the console:\n   * // x is equal to the count on the interval eg(0,1,2,3,...)\n   * // x will occur every 1000ms\n   * // if x % 2 is equal to 1 print abc\n   * // if x % 2 is not equal to 1 nothing will be output\n   *\n   * @see {@link create}\n   * @see {@link never}\n   * @see {@link of}\n   * @see {@link throw}\n   *\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emission of the complete notification.\n   * @return {Observable} An \"empty\" Observable: emits only the complete\n   * notification.\n   * @static true\n   * @name empty\n   * @owner Observable\n   */\n  static create<T>(scheduler?: IScheduler): Observable<T> {\n    return new EmptyObservable<T>(scheduler);\n  }\n\n  static dispatch<T>(arg: DispatchArg<T>) {\n    const { subscriber } = arg;\n    subscriber.complete();\n  }\n\n  constructor(private scheduler?: IScheduler) {\n    super();\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber });\n    } else {\n      subscriber.complete();\n    }\n  }\n}\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayObservable<T> extends Observable<T> {\n\n  static create<T>(array: T[], scheduler?: IScheduler): Observable<T> {\n    return new ArrayObservable(array, scheduler);\n  }\n\n  static of<T>(item1: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(...array: Array<T | IScheduler>): Observable<T>;\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n  static of<T>(...array: Array<T | IScheduler>): Observable<T> {\n    let scheduler = <IScheduler>array[array.length - 1];\n    if (isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    const len = array.length;\n    if (len > 1) {\n      return new ArrayObservable<T>(<any>array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable<T>(<any>array[0], scheduler);\n    } else {\n      return new EmptyObservable<T>(scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n\n    const { array, index, count, subscriber } = state;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  value: any;\n\n  constructor(private array: T[], private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const array = this.array;\n    const count = array.length;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array, index, count, subscriber\n      });\n    } else {\n      for (let i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayLikeObservable<T> extends Observable<T> {\n\n  static create<T>(arrayLike: ArrayLike<T>, scheduler?: IScheduler): Observable<T> {\n    const length = arrayLike.length;\n    if (length === 0) {\n      return new EmptyObservable<T>();\n    } else if (length === 1) {\n      return new ScalarObservable<T>(<any>arrayLike[0], scheduler);\n    } else {\n      return new ArrayLikeObservable(arrayLike, scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n    const { arrayLike, index, length, subscriber } = state;\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    if (index >= length) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(arrayLike[index]);\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  private value: any;\n\n  constructor(private arrayLike: ArrayLike<T>, private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && arrayLike.length === 1) {\n      this._isScalar = true;\n      this.value = arrayLike[0];\n    }\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const { arrayLike, scheduler } = this;\n    const length = arrayLike.length;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n        arrayLike, index, length, subscriber\n      });\n    } else {\n      for (let i = 0; i < length && !subscriber.closed; i++) {\n        subscriber.next(arrayLike[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n","import { PartialObserver } from './Observer';\nimport { Observable } from './Observable';\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nexport class Notification<T> {\n  hasValue: boolean;\n\n  constructor(public kind: string, public value?: T, public error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Delivers to the given `observer` the value wrapped by this Notification.\n   * @param {Observer} observer\n   * @return\n   */\n  observe(observer: PartialObserver<T>): any {\n    switch (this.kind) {\n      case 'N':\n        return observer.next && observer.next(this.value);\n      case 'E':\n        return observer.error && observer.error(this.error);\n      case 'C':\n        return observer.complete && observer.complete();\n    }\n  }\n\n  /**\n   * Given some {@link Observer} callbacks, deliver the value represented by the\n   * current Notification to the correctly corresponding callback.\n   * @param {function(value: T): void} next An Observer `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return next && next(this.value);\n      case 'E':\n        return error && error(this.error);\n      case 'C':\n        return complete && complete();\n    }\n  }\n\n  /**\n   * Takes an Observer or its individual callback functions, and calls `observe`\n   * or `do` methods accordingly.\n   * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n   * the `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    if (nextOrObserver && typeof (<PartialObserver<T>>nextOrObserver).next === 'function') {\n      return this.observe(<PartialObserver<T>>nextOrObserver);\n    } else {\n      return this.do(<(value: T) => void>nextOrObserver, error, complete);\n    }\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   * @return {any}\n   */\n  toObservable(): Observable<T> {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return Observable.of(this.value);\n      case 'E':\n        return Observable.throw(this.error);\n      case 'C':\n        return Observable.empty<T>();\n    }\n    throw new Error('unexpected notification kind value');\n  }\n\n  private static completeNotification: Notification<any> = new Notification('C');\n  private static undefinedValueNotification: Notification<any> = new Notification('N', undefined);\n\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   */\n  static createNext<T>(value: T): Notification<T> {\n    if (typeof value !== 'undefined') {\n      return new Notification('N', value);\n    }\n    return Notification.undefinedValueNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   */\n  static createError<T>(err?: any): Notification<T> {\n    return new Notification('E', undefined, err);\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   */\n  static createComplete(): Notification<any> {\n    return Notification.completeNotification;\n  }\n}\n","import { isArray } from '../util/isArray';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { PromiseObservable } from './PromiseObservable';\nimport { IteratorObservable } from'./IteratorObservable';\nimport { ArrayObservable } from './ArrayObservable';\nimport { ArrayLikeObservable } from './ArrayLikeObservable';\n\nimport { IScheduler } from '../Scheduler';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObserveOnSubscriber } from '../operator/observeOn';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class FromObservable<T> extends Observable<T> {\n  constructor(private ish: ObservableInput<T>, private scheduler?: IScheduler) {\n    super(null);\n  }\n\n  static create<T>(ish: ObservableInput<T>, scheduler?: IScheduler): Observable<T>;\n  static create<T, R>(ish: ArrayLike<T>, scheduler?: IScheduler): Observable<R>;\n\n  /**\n   * Creates an Observable from an Array, an array-like object, a Promise, an\n   * iterable object, or an Observable-like object.\n   *\n   * <span class=\"informal\">Converts almost anything to an Observable.</span>\n   *\n   * <img src=\"./img/from.png\" width=\"100%\">\n   *\n   * Convert various other objects and data types into Observables. `from`\n   * converts a Promise or an array-like or an\n   * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n   * object into an Observable that emits the items in that promise or array or\n   * iterable. A String, in this context, is treated as an array of characters.\n   * Observable-like objects (contains a function named with the ES2015 Symbol\n   * for Observable) can also be converted through this operator.\n   *\n   * @example <caption>Converts an array to an Observable</caption>\n   * var array = [10, 20, 30];\n   * var result = Rx.Observable.from(array);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 10 20 30\n   *\n   * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n   * function* generateDoubles(seed) {\n   *   var i = seed;\n   *   while (true) {\n   *     yield i;\n   *     i = 2 * i; // double it\n   *   }\n   * }\n   *\n   * var iterator = generateDoubles(3);\n   * var result = Rx.Observable.from(iterator).take(10);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 3 6 12 24 48 96 192 384 768 1536\n   *\n   * @see {@link create}\n   * @see {@link fromEvent}\n   * @see {@link fromEventPattern}\n   * @see {@link fromPromise}\n   *\n   * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n   * Observable-like, an Array, an iterable or an array-like object to be\n   * converted.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * emissions of values.\n   * @return {Observable<T>} The Observable whose values are originally from the\n   * input object that was converted.\n   * @static true\n   * @name from\n   * @owner Observable\n   */\n  static create<T>(ish: ObservableInput<T>, scheduler?: IScheduler): Observable<T> {\n    if (ish != null) {\n      if (typeof ish[Symbol_observable] === 'function') {\n        if (ish instanceof Observable && !scheduler) {\n          return ish;\n        }\n        return new FromObservable<T>(ish, scheduler);\n      } else if (isArray(ish)) {\n        return new ArrayObservable<T>(ish, scheduler);\n      } else if (isPromise<T>(ish)) {\n        return new PromiseObservable<T>(ish, scheduler);\n      } else if (typeof ish[Symbol_iterator] === 'function' || typeof ish === 'string') {\n        return new IteratorObservable<T>(ish, scheduler);\n      } else if (isArrayLike(ish)) {\n        return new ArrayLikeObservable(ish, scheduler);\n      }\n    }\n\n    throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>) {\n    const ish = this.ish;\n    const scheduler = this.scheduler;\n    if (scheduler == null) {\n      return ish[Symbol_observable]().subscribe(subscriber);\n    } else {\n      return ish[Symbol_observable]().subscribe(new ObserveOnSubscriber(subscriber, scheduler, 0));\n    }\n  }\n}\n","import {  FromObservable  } from './FromObservable';\n\nexport const from = FromObservable.create;","import { Observable } from '../../Observable';\nimport { from as staticFrom } from '../../observable/from';\n\nObservable.from = staticFrom;\n\ndeclare module '../../Observable' {\n  namespace Observable {\n    export let from: typeof staticFrom;\n  }\n}","import { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/dom/ajax';\nimport 'rxjs/add/observable/from';\n\nexport class Helper {\n\n\t/**\n\t * Returns an Observable from an AJAX call\n\t * @param url\n\t * @returns {Observable}\n\t */\n\tpublic static ajaxObservable(url) {\n\t\treturn Observable.ajax({\n\t\t\turl: url,\n\t\t\tcrossDomain: true\n\t\t}).map(ajax => {\n\t\t\treturn ajax.response;\n\t\t});\n\t}\n\n}","import { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/dom/ajax';\nimport 'rxjs/add/operator/map';\n\nimport { SearchResult } from '../model/search-result';\nimport { Context } from '../context';\nimport { Movie } from '../model/movie';\nimport { Company } from '../model/company';\nimport { Collection } from '../model/collection';\nimport { Keyword } from '../model/keyword';\nimport { TvShow } from '../model/tv-show';\nimport { Person } from '../model/person';\nimport { Helper } from '../helper';\n\nexport class SearchApi {\n\n\tconstructor(private context: Context) {\n\t}\n\n\t/**\n\t * Builds the endpoint URL depending on which resource we are looking for\n\t * @param resource company, collection, keyword, movie, tv, person...\n\t * @param query\n\t * @returns {string}\n\t */\n\tprivate url(resource: string, query: string, page: number) {\n\t\treturn `${this.context.baseUrl}/search/${resource}?api_key=${this.context.apiKey}&language=${this.context.language}&query=${query}&page=${page}`;\n\t}\n\n\tcollections(query: string, page = 1): Observable<SearchResult<Collection>> {\n\t\treturn Helper.ajaxObservable(this.url('collection', query, page));\n\t}\n\n\tcompanies(query: string, page = 1): Observable<SearchResult<Company>> {\n\t\treturn Helper.ajaxObservable(this.url('company', query, page));\n\t}\n\n\tkeywords(query: string, page = 1): Observable<SearchResult<Keyword>> {\n\t\treturn Helper.ajaxObservable(this.url('keyword', query, page));\n\t}\n\n\tmovies(query: string, page = 1): Observable<SearchResult<Movie>> {\n\t\treturn Helper.ajaxObservable(this.url('movie', query, page));\n\t}\n\n\tmulti(query: string, page = 1): Observable<SearchResult<Movie | TvShow | Person>> {\n\t\treturn Helper.ajaxObservable(this.url('multi', query, page));\n\t}\n\n\tpeople(query: string, page = 1): Observable<SearchResult<Person>> {\n\t\treturn Helper.ajaxObservable(this.url('person', query, page));\n\t}\n\n\ttvshows(query: string, page = 1): Observable<SearchResult<TvShow>> {\n\t\treturn Helper.ajaxObservable(this.url('tv', query, page));\n\t}\n\n}","export class Context {\n\tapiKey: string;\n\tlanguage: string = 'en';\n\tbaseUrl = 'https://api.themoviedb.org/3';\n}","import { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\n\nimport { Context } from '../context';\nimport { Helper } from '../helper';\nimport { MovieDetails } from '../model/movie-details';\n\nexport class MoviesApi {\n\n\tconstructor(private context: Context) {\n\t}\n\n\tdetails(movieId: number): Observable<MovieDetails> {\n\t\tconst url = `${this.context.baseUrl}/movie/${movieId}?api_key=${this.context.apiKey}&language=${this.context.language}`;\n\t\treturn Helper.ajaxObservable(url);\n\t}\n\n}","import { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\n\nimport { Context } from '../context';\nimport { Helper } from '../helper';\nimport { CollectionDetails } from '../model/collection-details';\n\nexport class CollectionsApi {\n\n\tconstructor(private context: Context) {\n\t}\n\n\tdetails(collectionId: number): Observable<CollectionDetails> {\n\t\tconst url = `${this.context.baseUrl}/collection/${collectionId}?api_key=${this.context.apiKey}&language=${this.context.language}`;\n\t\treturn Helper.ajaxObservable(url);\n\t}\n\n}","import { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\n\nimport { Context } from '../context';\nimport { Helper } from '../helper';\nimport { PersonDetails } from '../model/person-details';\n\nexport class PeopleApi {\n\n\tconstructor(private context: Context) {\n\t}\n\n\tdetails(personId: number): Observable<PersonDetails> {\n\t\tconst url = `${this.context.baseUrl}/person/${personId}?api_key=${this.context.apiKey}&language=${this.context.language}`;\n\t\treturn Helper.ajaxObservable(url);\n\t}\n\n}","import { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\n\nimport { Context } from '../context';\nimport { Helper } from '../helper';\nimport { TvShowDetails } from '../model/tv-show-details';\n\nexport class TvApi {\n\n\tconstructor(private context: Context) {\n\t}\n\n\tdetails(showId: number): Observable<TvShowDetails> {\n\t\tconst url = `${this.context.baseUrl}/tv/${showId}?api_key=${this.context.apiKey}&language=${this.context.language}`;\n\t\treturn Helper.ajaxObservable(url);\n\t}\n\n}","import { SearchApi } from './features/search-api';\nimport { Context } from './context';\nimport { MoviesApi } from './features/movies-api';\nimport { CollectionsApi } from './features/collections-api';\nimport { PeopleApi } from './features/people-api';\nimport { TvApi } from './features/tv-api';\n\nexport class TmdbApi {\n\n\tcontext: Context;\n\n\tprivate _search: SearchApi;\n\tprivate _movies: MoviesApi;\n\tprivate _collections: CollectionsApi;\n\tprivate _people: PeopleApi;\n\tprivate _tvshows: TvApi;\n\n\tconstructor(apiKey: string, language = 'en') {\n\t\tthis.context = new Context();\n\t\tthis.context.apiKey = apiKey;\n\t\tthis.context.language = language;\n\t}\n\n\tget search() {\n\t\treturn this._search || (this._search = new SearchApi(this.context));\n\t}\n\n\tget movies() {\n\t\treturn this._movies || (this._movies = new MoviesApi(this.context));\n\t}\n\n\tget collections() {\n\t\treturn this._collections || (this._collections = new CollectionsApi(this.context));\n\t}\n\n\tget people() {\n\t\treturn this._people || (this._people = new PeopleApi(this.context));\n\t}\n\n\tget tvshows() {\n\t\treturn this._tvshows || (this._tvshows = new TvApi(this.context));\n\t}\n\n}\n","import { Collection } from './collection';\nimport { Movie } from './movie';\nexport class CollectionDetails extends Collection {\n\toverview: string;\n\tparts: Movie[];\n}","import { Movie } from './movie';\nimport { Collection } from './collection';\nimport { Genre } from './genre';\nimport { Company } from './company';\nimport { Country } from './country';\nimport { Language } from './language';\n\nexport class MovieDetails extends Movie {\n\tbelongs_to_collection: Collection;\n\tbudget: number;\n\tgenres: Genre[];\n\thomepage: string;\n\timdb_id: string;\n\tproduction_companies: Company[];\n\tproduction_countries: Country[];\n\trevenue: number;\n\truntime: number;\n\tspoken_languages: Language[];\n\tstatus: string;\n\ttagline: string;\n}","import { Person } from './person';\n\nexport class PersonDetails extends Person {\n\talso_known_as: string[];\n\tbiography: string;\n\tbirthday: Date;\n\tdeathday: Date;\n\tgender: number;\n\thomepage: string;\n\timdb_id: string;\n\tplace_of_birth: string;\n}","import { TvShow } from './tv-show';\nimport { Person } from './person';\nimport { Genre } from './genre';\nimport { Network } from './network';\nimport { Company } from './company';\nimport { Season } from './season';\n\nexport class TvShowDetails extends TvShow {\n\tcreated_by: Person[] = [];\n\tepisode_run_time: number[] = [];\n\tgenres: Genre[];\n\thomepage: string;\n\tin_production: boolean;\n\tlanguages: string[] = [];\n\tnetworks: Network[] = [];\n\tnumber_of_episodes: number;\n\tnumber_of_seasons: number;\n\tproduction_companies: Company[] = [];\n\tseasons: Season[] = [];\n\tstatus: string;\n\ttype: string;\n\tlast_air_date: Date;\n}"],"names":["x","tryCatchTarget","apply","this","arguments","e","errorObject_1","fn","tryCatcher","errors","reduce","errs","err","concat","UnsubscriptionError_1","nextOrObserver","error","complete","Subscriber_1","rxSubscriber_1","Observer_1","project","thisArg","TypeError","lift","MapOperator","root_1","XMLHttpRequest","XDomainRequest","Error","progId","progIds","i","ActiveXObject","url","headers","AjaxObservable","method","body","responseType","map_1","index","response","value","subscribe","then","arg","subscriber","closed","next","obj","iterator_1","StringIterator","undefined","length","ArrayIterator","o","len","isNaN","numberIsFinite","sign","Math","floor","abs","maxSafeInteger","isFinite","valueAsNumber","schedule","scheduler","delay","ObserveOnOperator","__extends","d","b","__","constructor","extendStatics","prototype","Object","create","__window","window","__self","self","WorkerGlobalScope","__global","global","_root","Array","isArray","_super","call","map","toString","join","name","stack","message","unsubscribe","_unsubscribe","Subscription","hasErrors","_a","_parent","_parents","_subscriptions","remove","isFunction_1","trial","tryCatch_1","flattenUnsubscriptionErrors","isArray_1","sub","isObject_1","push","teardown","EMPTY","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","empty","Symbol","exports","for","destinationOrNext","destination","Subscriber","add","syncErrorThrowable","SafeSubscriber","isStopped","_next","_error","_complete","Subscription_1","_parentSubscriber","observerOrNext","context","bind","_context","__tryOrSetError","__tryOrUnsub","syncErrorValue","syncErrorThrown","wrappedComplete","_this","$$observable","observable","getSymbolObservable","_subscribe","Observable","operator","source","sink","toSubscriber_1","_trySubscribe","PromiseCtor","Rx","config","Promise","resolve","reject","observable_1","MapSubscriber","result","count","urlOrRequest","request","async","createXHR","crossDomain","getCORSRequest","getXMLHttpRequest","withCredentials","timeout","prop","hasOwnProperty","AjaxSubscriber","get","ajaxGet","post","ajaxPost","delete","ajaxDelete","put","ajaxPut","patch","ajaxPatch","getJSON","ajaxGetJSON","Observable_1","FormData","serializeBody","send","done","xhr","AjaxResponse","_b","user","password","setupEvents","open","setHeaders","contentType","splitIndex","substring","keys","key","encodeURI","JSON","stringify","setRequestHeader","progressSubscriber","AjaxTimeoutError","readyState","status_1","status","responseText","AjaxError","ontimeout","xhrTimeout","upload","xhrProgress_1","onprogress","xhrError_1","onerror","onreadystatechange","xhrReadyStateChange","abort","originalEvent","parse","responseXML","AjaxObservable_1","ajax","ajax_1","promise","PromiseObservable","_isScalar","setTimeout","dispatchNext","dispatchError","root","iterator","Set_1","Map_1","getOwnPropertyNames","symbolIteratorPonyfill","getIterator","IteratorObservable","state","hasError","return","dispatch","str","idx","charAt","arr","toLength","pow","ScalarObservable","EmptyObservable","array","ArrayObservable","_i","isScheduler_1","pop","ScalarObservable_1","EmptyObservable_1","arrayLike","ArrayLikeObservable","kind","hasValue","Notification","observer","observe","do","of","throw","undefinedValueNotification","completeNotification","ObserveOnSubscriber","notification","ObserveOnMessage","scheduleMessage","Notification_1","createNext","createError","createComplete","ish","FromObservable","ArrayObservable_1","isPromise_1","PromiseObservable_1","IteratorObservable_1","isArrayLike_1","ArrayLikeObservable_1","observeOn_1","FromObservable_1","from","from_1","resource","query","page","baseUrl","apiKey","language","Helper","ajaxObservable","movieId","collectionId","personId","showId","Context","TmdbApi","_search","SearchApi","_movies","MoviesApi","_collections","CollectionsApi","_people","PeopleApi","_tvshows","TvApi","setPrototypeOf","__proto__","p","Collection","Movie","Person","TvShow"],"mappings":"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"}